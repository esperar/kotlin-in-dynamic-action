# 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법

## 기본 요소: 함수와 변수

### Hello World

이제는 고전이 된 예제인 Hello World를 찍는 프로그램으로 싲가을 해본다.

```kt
fun main(args: Array<String>) {
    println("Hello World")
}
```

이렇게 간단한 코드에서 어떤 코틀린 문법이나 특성을 발견할 수 있을까?

- 함수를 선언할 때 `fun` 키워드를 사용한다. 실제로 코틀린에서 함수를 만드는 일은 신나는(fun)일이다.

- 파라미터 이름 뒤에 그 파라미터 타입을 작성한다.
- 함수를 최상위 수준에 정의할 수 있다. (자바와 달리 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.)
- 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- System.out.println 대신에 println이라고 쓴다. (코틀린의 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼wrapper를 제공한다.)
- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 새미콜론을 붙이지 않아도 된다.

### 함수

코틀린에서 함수를 작성할 때 반환 타입을 어디에 지정해야 할 까?

```kt
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}

fun main() {
    println(max(1,2)) // 2
}
```

함수 선언은 fun 키워드로 시작하고, fun 다음에는 함수 이름이 온다.
  
함수 이름 뒤에는 괄호 괄호 안에는 파라미터 목록이 오고, 함수의 반환 타입은 파라미터 목록의 다는 괄호 다음에 오는데 괄호와 반환 타입 사이에 콜론(:)이 있다.
  
코틀린은 if는(값을 만들어내지 못하는) 문장이 아니고 결과를 만드는 식(expression)이라는 점이 흥미롭다.
  
이 예제의 코틀린 if 식은 자바 3항 연산자로 작성한 (a > b) ? a : b 식과 비슷하다.

### 문(statement)와 식(expression)의 구분

- 문(statement)
  - 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.
- 식(expression)
  - 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.

### 식이 본문인 함수

방금 작성한 max 함수는 return대신 = 하나로만 표현할 수 있다.

```kt
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라고 부르고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 부른다.
  
반환 타입을 생략하면 max 함수를 더욱 간략하게 만들 수 있다.

```kt
fun max(a: Int, b: Int) = if (a > b) a else b
```

여기서 반환 타입을 생략할 수 있는 이유는?   
  
코틀린은 정적 타입 지정 언어이므로 컴파일 시점에 모든 식의 타입을 지정해야 한다.
  
실제로 모든 변수나 모든 식에는 타입이 있으며, 모든 함수는 반환 타입이 정해여쟈 한다. 
  
하지만 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 함수 반환 타입으로 정해준다. `타입 추론`
  
그러나 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return 문을 사용해야한다.

### 변수
자바에서 변수를 선언할 때 타입이 맨 앞에 온다. 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
  
타입으로 변수 선언을 시작하면 타입을 생략할 경우 변수 선언을 구별할 수 없다.
  
그런 이유로 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

```kt
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer: Int = 42
```

식이 본문인 함수와 마찬가지로 여러분이 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
  
초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 따라서 그런 경우 타입을 반드시 지정해야 한다.

```kt
val answer: Int
answer = 42
```

### 변경 가능한 변수와 변경 불가능한 변수
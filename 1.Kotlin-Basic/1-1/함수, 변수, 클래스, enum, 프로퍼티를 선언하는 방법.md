# 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법

## 기본 요소: 함수와 변수

### Hello World

이제는 고전이 된 예제인 Hello World를 찍는 프로그램으로 싲가을 해본다.

```kt
fun main(args: Array<String>) {
    println("Hello World")
}
```

이렇게 간단한 코드에서 어떤 코틀린 문법이나 특성을 발견할 수 있을까?

- 함수를 선언할 때 `fun` 키워드를 사용한다. 실제로 코틀린에서 함수를 만드는 일은 신나는(fun)일이다.

- 파라미터 이름 뒤에 그 파라미터 타입을 작성한다.
- 함수를 최상위 수준에 정의할 수 있다. (자바와 달리 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.)
- 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- System.out.println 대신에 println이라고 쓴다. (코틀린의 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼wrapper를 제공한다.)
- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 새미콜론을 붙이지 않아도 된다.

<br>

### 함수

코틀린에서 함수를 작성할 때 반환 타입을 어디에 지정해야 할 까?

```kt
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}

fun main() {
    println(max(1,2)) // 2
}
```

함수 선언은 fun 키워드로 시작하고, fun 다음에는 함수 이름이 온다.
  
함수 이름 뒤에는 괄호 괄호 안에는 파라미터 목록이 오고, 함수의 반환 타입은 파라미터 목록의 다는 괄호 다음에 오는데 괄호와 반환 타입 사이에 콜론(:)이 있다.
  
코틀린은 if는(값을 만들어내지 못하는) 문장이 아니고 결과를 만드는 식(expression)이라는 점이 흥미롭다.
  
이 예제의 코틀린 if 식은 자바 3항 연산자로 작성한 (a > b) ? a : b 식과 비슷하다.

<br>

### 문(statement)와 식(expression)의 구분

- 문(statement)
  - 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.
- 식(expression)
  - 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.

<br>

### 식이 본문인 함수

방금 작성한 max 함수는 return대신 = 하나로만 표현할 수 있다.

```kt
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라고 부르고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 부른다.
  
반환 타입을 생략하면 max 함수를 더욱 간략하게 만들 수 있다.

```kt
fun max(a: Int, b: Int) = if (a > b) a else b
```

여기서 반환 타입을 생략할 수 있는 이유는?   
  
코틀린은 정적 타입 지정 언어이므로 컴파일 시점에 모든 식의 타입을 지정해야 한다.
  
실제로 모든 변수나 모든 식에는 타입이 있으며, 모든 함수는 반환 타입이 정해여쟈 한다. 
  
하지만 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 함수 반환 타입으로 정해준다.   
`타입 추론`
  
그러나 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return 문을 사용해야한다.

<br>

### 변수
자바에서 변수를 선언할 때 타입이 맨 앞에 온다. 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
  
타입으로 변수 선언을 시작하면 타입을 생략할 경우 변수 선언을 구별할 수 없다.
  
그런 이유로 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

```kt
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer: Int = 42
```

식이 본문인 함수와 마찬가지로 여러분이 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
  
초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 따라서 그런 경우 타입을 반드시 지정해야 한다.

```kt
val answer: Int
answer = 42
```

<br>

### 변경 가능한 변수와 변경 불가능한 변수

변수 선언 시 사용하는 키워드는 `val`, `var` 다음과 같이 2가지가 있다.

```kt
val a = 3 // 값 변경이 불가능한 참조를 저장하는 변수 
var b = 4 // 값 변경이 가능한 참조, 변수의 값은 바뀔 수 있다.
```

val 변수의 초기화는 무조건 한 번만 초기화 돼야한다.
  
하지만 어떤 블록에 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

```kt
val message: String

if(canPerformOperation()) {
    message = "Success"
    // .. 연산을 수행
} else {
    message = "Failed
}
```

val 키워드는 참조 자체는 불변이라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억하자.

```kt
val languages = arrayListOf("Java") // 불변 참조를 선언한다.
languages.add("Kotlin") // 참조가 가리키는 객체 내부를 변경한다.
```

### 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kt
fun main(args: Array<String>) {
    val name = if (args.,size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```

이 예제는 문자열 템플릿이라는 기능을 보여준다. 이 코드는 name이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리터럴 안에서 그 변수를 사용했다.
  
여러 스크립트 언어와 비슷하게 코틀린에서도 변수를 문자열 안에 사용할 수 있다.
  
문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 &를 추가해야 한다.

```kt
fun main(args: Array<String>) {
    val name = if (args.,size > 0) args[0] else "Kotlin"
    println("Hello, ${args[0]}!")
}
```